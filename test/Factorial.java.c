// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

extern void* prev;
// structures
struct Factorial{

  struct Factorial_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding; 
    void *v;
};
struct Fac{

  struct Fac_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding; 
    void *v;
};
// vtables structures
struct Factorial_vtable
{
   char* Factorial_gc_map; 
};



struct Factorial_vtable Factorial_vtable_; 
struct Fac_vtable
{
   char* Fac_gc_map; 
  int (*ComputeFac)();
};



struct Fac_vtable Fac_vtable_; 

// methods
int Fac_ComputeFac_arguments_gc_map = 1;
int Fac_ComputeFac_locals_gc_map = 0;
struct Fac_ComputeFac_gc_frame{
      void *prev;
      int arguments_gc_map;
      int locals_gc_map;
      void *arguments_base_address;
      void *v;
  void *y_0;
};
int Fac_ComputeFac(struct Fac * this, int num)
{
  int num_aux;
  struct Fac * x_1;
  int x_2;
  int x_3;
  int x_4;
  int x_5;

    struct Fac_ComputeFac_gc_frame frame;
    frame.prev = prev;
    prev = &frame;
    frame.arguments_gc_map = Fac_ComputeFac_arguments_gc_map;
    frame.locals_gc_map = Fac_ComputeFac_locals_gc_map;
    frame.arguments_base_address = &(frame.v) + frame.locals_gc_map + 1;
    frame.v = &(frame.v) + 1;
  frame.y_0 = &this;
L_0:
  this = this;    //0
  num = num;    //1
  x_2 = num < 1;    //2
  if (x_2)
    goto L_1;
  else
    goto L_2;
                 //3
L_2:
  x_5 = num - 1;    //4
  x_4 = this->vptr->ComputeFac(this, x_5);    //5
  x_3 = num * x_4;    //6
  num_aux = x_3;    //7
  goto L_3;
                 //8
L_1:
  num_aux = 1;    //9
  goto L_3;
                 //10
L_3:
      prev=frame.prev;
  return num_aux;                 //11

}

// vtables
struct Factorial_vtable Factorial_vtable_ = 
{
"",
};

struct Fac_vtable Fac_vtable_ = 
{
"",
  Fac_ComputeFac,
};


// main method
int Tiger_main_arguments_gc_map = 0;
int Tiger_main_locals_gc_map = 0;
struct Tiger_main_gc_frame{
      void *prev;
      int arguments_gc_map;
      int locals_gc_map;
      void *arguments_base_address;
      void *v;
};
int Tiger_main ()
{
    struct Tiger_main_gc_frame frame;
    frame.prev = prev;
    prev = &frame;
    frame.arguments_gc_map = Tiger_main_arguments_gc_map;
    frame.locals_gc_map  = Tiger_main_locals_gc_map;
     frame.arguments_base_address = &(frame.v) + frame.locals_gc_map + 1;
    frame.v = &(frame.v) + 1;
  struct Fac * x_0;
  int x_6;
  struct Fac * x_7;

L_4:
  x_7 = ((struct Fac*)(Tiger_new (&Fac_vtable_, sizeof(struct Fac))));    //0
  x_6 = x_7->vptr->ComputeFac(x_7, 10);    //1
  System_out_println (x_6);    //2
      prev=frame.prev;
  return 0;                 //3

}




